//! KDL Index-Based Parser (Stage 2 of Two-Stage Parsing)
//!
//! This parser consumes a StructuralIndex generated by Stage 1.
//! It uses structural offsets to jump across tokens while keeping
//! parsing semantics aligned with the streaming parser.

const std = @import("std");
const constants = @import("../util/constants.zig");
const simd = @import("../simd.zig");
const structural = @import("structural.zig");
const stream_events = @import("../stream/stream_events.zig");
const unicode = @import("../util/unicode.zig");
const numbers = @import("../util/numbers.zig");
const grammar = @import("../util/grammar.zig");
const value_builder = @import("../stream/value_builder.zig");
const StreamDocument = @import("../stream/stream_types.zig").StreamDocument;
const StringRef = @import("../stream/stream_types.zig").StringRef;
const NodeHandle = @import("../stream/stream_types.zig").NodeHandle;
const StreamValue = @import("../stream/stream_types.zig").StreamValue;
const DecodeUtf8Result = @TypeOf(unicode.decodeUtf8(""));

pub const ParseError = error{
    UnexpectedToken,
    UnexpectedEof,
    InvalidNumber,
    InvalidString,
    InvalidEscape,
    InvalidSyntax,
    MaxDepthExceeded,
    UnsupportedFeature,
    OutOfMemory,
};

pub const Options = struct {
    max_depth: u16 = constants.DEFAULT_MAX_DEPTH,
};

const TokenKind = enum {
    identifier,
    quoted_string,
    raw_string,
    multiline_string,
    number,
    keyword,
};

const TokenInfo = struct {
    kind: TokenKind,
    start: usize,
    end: usize,
    text: []const u8,
    str_ref: ?StringRef = null,
};

const ContiguousOps = struct {
    inline fn len(source: *const []const u8) usize {
        return source.*.len;
    }

    inline fn byteAt(source: *const []const u8, pos: usize) ?u8 {
        if (pos >= source.*.len) return null;
        return source.*[pos];
    }

    inline fn spanFrom(source: *const []const u8, pos: usize) []const u8 {
        if (pos >= source.*.len) return "";
        return source.*[pos..];
    }

    inline fn slice(
        source: *const []const u8,
        allocator: std.mem.Allocator,
        scratch: *std.ArrayList(u8),
        start: usize,
        end: usize,
    ) std.mem.Allocator.Error![]const u8 {
        _ = allocator;
        _ = scratch;
        return source.*[start..end];
    }
};

const ChunkedSourceCursor = struct {
    source: structural.ChunkedSource,
    chunk_index: usize = 0,
    chunk_start: usize = 0,
    chunk_end: usize = 0,

    fn init(source: structural.ChunkedSource) ChunkedSourceCursor {
        var cursor = ChunkedSourceCursor{ .source = source };
        if (source.chunks.len > 0) {
            cursor.chunk_start = source.offsets[0];
            cursor.chunk_end = cursor.chunk_start + source.chunks[0].len;
        }
        return cursor;
    }
};

const ChunkedOps = struct {
    inline fn len(source: *const ChunkedSourceCursor) usize {
        return source.source.total_len;
    }

    inline fn spanFrom(source: *ChunkedSourceCursor, pos: usize) []const u8 {
        if (pos >= source.source.total_len) return "";
        ensureChunkFor(source, pos);
        const chunk = currentChunk(source);
        return chunk[(pos - source.chunk_start)..];
    }

    inline fn byteAt(source: *ChunkedSourceCursor, pos: usize) ?u8 {
        if (pos >= source.source.total_len) return null;
        ensureChunkFor(source, pos);
        const chunk = currentChunk(source);
        return chunk[pos - source.chunk_start];
    }

    inline fn slice(
        source: *ChunkedSourceCursor,
        allocator: std.mem.Allocator,
        scratch: *std.ArrayList(u8),
        start: usize,
        end: usize,
    ) std.mem.Allocator.Error![]const u8 {
        if (end <= start) return "";
        if (start >= source.source.total_len) return "";
        ensureChunkFor(source, start);
        const chunk = currentChunk(source);
        if (end <= source.chunk_end) {
            return chunk[(start - source.chunk_start)..(end - source.chunk_start)];
        }

        scratch.clearRetainingCapacity();
        var pos = start;
        while (pos < end) {
            ensureChunkFor(source, pos);
            const cur = currentChunk(source);
            const local_start = pos - source.chunk_start;
            const take = @min(end, source.chunk_end) - pos;
            try scratch.appendSlice(allocator, cur[local_start..][0..take]);
            pos += take;
        }
        return scratch.items;
    }

    inline fn currentChunk(source: *const ChunkedSourceCursor) []const u8 {
        const chunk = source.source.chunks[source.chunk_index];
        return chunk.data[0..chunk.len];
    }

    inline fn ensureChunkFor(source: *ChunkedSourceCursor, pos: usize) void {
        if (pos >= source.chunk_start and pos < source.chunk_end) return;
        if (source.source.chunks.len == 0) {
            source.chunk_start = 0;
            source.chunk_end = 0;
            return;
        }
        if (pos >= source.chunk_end) {
            while (source.chunk_index + 1 < source.source.chunks.len and pos >= source.source.offsets[source.chunk_index + 1]) {
                source.chunk_index += 1;
            }
        } else if (pos < source.chunk_start) {
            var lo: usize = 0;
            var hi: usize = source.source.offsets.len;
            while (lo + 1 < hi) {
                const mid = (lo + hi) / 2;
                if (source.source.offsets[mid] <= pos) {
                    lo = mid;
                } else {
                    hi = mid;
                }
            }
            source.chunk_index = lo;
        }
        source.chunk_start = source.source.offsets[source.chunk_index];
        source.chunk_end = source.chunk_start + source.source.chunks[source.chunk_index].len;
    }
};

fn IndexParserImpl(comptime SourceType: type, comptime Ops: type) type {
    return struct {
        const Self = @This();

        allocator: std.mem.Allocator,
        source: SourceType,
        index: structural.StructuralIndex,
        idx_pos: usize = 0,
        cursor: usize = 0,
        doc: ?*StreamDocument,
        depth: u16 = 0,
        options: Options,
        scratch: std.ArrayList(u8) = .empty,
        event_scratch: std.ArrayList(u8) = .empty,

        pub fn init(
            allocator: std.mem.Allocator,
            source: SourceType,
            index: structural.StructuralIndex,
            doc: *StreamDocument,
            options: Options,
        ) Self {
            return Self{
                .allocator = allocator,
                .source = source,
                .index = index,
                .doc = doc,
                .options = options,
            };
        }

        pub fn initKernel(
            allocator: std.mem.Allocator,
            source: SourceType,
            index: structural.StructuralIndex,
            options: Options,
        ) Self {
            return Self{
                .allocator = allocator,
                .source = source,
                .index = index,
                .doc = null,
                .options = options,
            };
        }

        pub fn deinit(self: *Self) void {
            self.scratch.deinit(self.allocator);
            self.event_scratch.deinit(self.allocator);
        }

        pub fn parse(self: *Self) ParseError!void {
            self.skipBOM();

            while (self.cursor < self.sourceLen()) {
                self.skipIgnored();
                if (self.cursor >= self.sourceLen()) break;

                const c = self.peek().?;
                if (isNewline(c)) {
                    self.consumeNewline();
                    continue;
                }
                if (self.isSlashdash()) {
                    return ParseError.UnsupportedFeature;
                }

                _ = try self.parseNode(null);
                self.skipIgnored();
            }
        }

        pub fn parseWithSink(self: *Self, sink: anytype) !void {
            self.skipBOM();

            while (self.cursor < self.sourceLen()) {
                self.skipIgnored();
                if (self.cursor >= self.sourceLen()) break;

                const c = self.peek().?;
                if (isNewline(c)) {
                    self.consumeNewline();
                    continue;
                }
                if (self.isSlashdash()) {
                    return ParseError.UnsupportedFeature;
                }

                try self.parseNodeToSink(sink);
                self.skipIgnored();
            }
        }

        inline fn sourceLen(self: *Self) usize {
            return Ops.len(&self.source);
        }

        inline fn byteAt(self: *Self, pos: usize) ?u8 {
            return Ops.byteAt(&self.source, pos);
        }

        inline fn spanFrom(self: *Self, pos: usize) []const u8 {
            return Ops.spanFrom(&self.source, pos);
        }

        fn sliceRange(self: *Self, start: usize, end: usize) ParseError![]const u8 {
            return Ops.slice(&self.source, self.allocator, &self.scratch, start, end) catch return ParseError.OutOfMemory;
        }

    fn parseNode(self: *Self, parent: ?NodeHandle) ParseError!NodeHandle {
        const doc = self.doc orelse unreachable;
        if (self.depth >= self.options.max_depth) {
            return ParseError.MaxDepthExceeded;
        }
        self.depth += 1;
        defer self.depth -= 1;

        self.skipIgnored();

        var type_annot = StringRef.empty;
        if (self.peek() == @as(?u8, '(')) {
            self.advanceCursor(1);
            self.skipIgnored();
            type_annot = try self.parseIdentifierOrString();
            self.skipIgnored();
            if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
            self.advanceCursor(1);
        }

        self.skipIgnored();
        const name = try self.parseIdentifierOrString();

        const arg_start: u64 = @intCast(doc.values.arguments.items.len);
        const prop_start: u64 = @intCast(doc.values.properties.items.len);

        while (true) {
            self.skipIgnored();
            if (self.cursor >= self.sourceLen()) break;
            const c = self.peek().?;
            if (c == ';' or isNewline(c) or c == '{' or c == '}') break;
            if (self.isSlashdash()) {
                return ParseError.UnsupportedFeature;
            }
            try self.parseArgumentOrProperty();
        }

        const arg_end: u64 = @intCast(doc.values.arguments.items.len);
        const prop_end: u64 = @intCast(doc.values.properties.items.len);

        const node = doc.nodes.addNode(
            name,
            type_annot,
            parent,
            .{ .start = arg_start, .count = arg_end - arg_start },
            .{ .start = prop_start, .count = prop_end - prop_start },
        ) catch return ParseError.OutOfMemory;

        if (parent == null) {
            doc.addRoot(node) catch return ParseError.OutOfMemory;
        } else {
            doc.nodes.linkChild(parent.?, node);
        }

        self.skipIgnored();
        var had_children = false;
        if (self.peek() == @as(?u8, '{')) {
            had_children = true;
            self.advanceCursor(1);
            while (true) {
                self.skipIgnored();
                while (self.peek()) |nc| {
                    if (!isNewline(nc)) break;
                    self.consumeNewline();
                    self.skipIgnored();
                }
                if (self.peek() == @as(?u8, '}')) {
                    self.advanceCursor(1);
                    break;
                }
                if (self.cursor >= self.sourceLen()) return ParseError.UnexpectedEof;
                if (self.isSlashdash()) {
                    return ParseError.UnsupportedFeature;
                }
                _ = try self.parseNode(node);
            }
        }

        self.skipIgnored();
        if (self.peek()) |term| {
            if (term == ';') {
                self.advanceCursor(1);
            } else if (isNewline(term)) {
                self.consumeNewline();
            } else if (had_children and term != '}') {
                return ParseError.UnexpectedToken;
            }
        }

        return node;
    }

    fn parseNodeToSink(self: *Self, sink: anytype) !void {
        if (self.depth >= self.options.max_depth) {
            return ParseError.MaxDepthExceeded;
        }
        self.depth += 1;
        defer self.depth -= 1;

        self.skipIgnored();
        self.event_scratch.clearRetainingCapacity();

        var type_annot: ?stream_events.StringView = null;
        if (self.peek() == @as(?u8, '(')) {
            self.advanceCursor(1);
            self.skipIgnored();
            type_annot = try self.parseIdentifierOrStringView();
            self.skipIgnored();
            if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
            self.advanceCursor(1);
            if (type_annot) |value| {
                type_annot = try self.pinView(value);
            }
        }

        self.skipIgnored();
        const name_raw = try self.parseIdentifierOrStringView();
        const name = try self.pinView(name_raw);
        try sink.onEvent(.{ .start_node = .{ .name = name, .type_annotation = type_annot } });

        while (true) {
            self.skipIgnored();
            if (self.cursor >= self.sourceLen()) break;
            const c = self.peek().?;
            if (c == ';' or isNewline(c) or c == '{' or c == '}') break;
            if (self.isSlashdash()) {
                return ParseError.UnsupportedFeature;
            }
            try self.parseArgumentOrPropertyToSink(sink);
        }

        self.skipIgnored();
        var had_children = false;
        if (self.peek() == @as(?u8, '{')) {
            had_children = true;
            self.advanceCursor(1);
            while (true) {
                self.skipIgnored();
                while (self.peek()) |nc| {
                    if (!isNewline(nc)) break;
                    self.consumeNewline();
                    self.skipIgnored();
                }
                if (self.peek() == @as(?u8, '}')) {
                    self.advanceCursor(1);
                    break;
                }
                if (self.cursor >= self.sourceLen()) return ParseError.UnexpectedEof;
                if (self.isSlashdash()) {
                    return ParseError.UnsupportedFeature;
                }
                try self.parseNodeToSink(sink);
            }
        }

        self.skipIgnored();
        if (self.peek()) |term| {
            if (term == ';') {
                self.advanceCursor(1);
            } else if (isNewline(term)) {
                self.consumeNewline();
            } else if (had_children and term != '}') {
                return ParseError.UnexpectedToken;
            }
        }

        try sink.onEvent(.end_node);
    }

    fn parseArgumentOrProperty(self: *Self) ParseError!void {
        const doc = self.doc orelse unreachable;
        var type_annot = StringRef.empty;
        if (self.peek() == @as(?u8, '(')) {
            self.advanceCursor(1);
            self.skipIgnored();
            type_annot = try self.parseIdentifierOrString();
            self.skipIgnored();
            if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
            self.advanceCursor(1);
        }

        self.skipIgnored();
        const token = try self.parseToken();

        self.skipIgnored();
        if (self.peek() == @as(?u8, '=')) {
            if (type_annot.len != 0) return ParseError.InvalidSyntax;
            if (token.str_ref == null or token.kind == .number or token.kind == .keyword) {
                return ParseError.InvalidSyntax;
            }
            self.advanceCursor(1);
            self.skipIgnored();

            var val_type = StringRef.empty;
            if (self.peek() == @as(?u8, '(')) {
                self.advanceCursor(1);
                self.skipIgnored();
                val_type = try self.parseIdentifierOrString();
                self.skipIgnored();
                if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
                self.advanceCursor(1);
            }

            const value = try self.parseValue();
            _ = doc.values.addProperty(.{
                .name = token.str_ref.?,
                .value = value,
                .type_annotation = val_type,
            }) catch return ParseError.OutOfMemory;
        } else {
            const value = try self.parseValueFromToken(token);
            _ = doc.values.addArgument(.{
                .value = value,
                .type_annotation = type_annot,
            }) catch return ParseError.OutOfMemory;
        }
    }

    fn parseArgumentOrPropertyToSink(self: *Self, sink: anytype) !void {
        self.event_scratch.clearRetainingCapacity();
        var type_annot: ?stream_events.StringView = null;
        if (self.peek() == @as(?u8, '(')) {
            self.advanceCursor(1);
            self.skipIgnored();
            type_annot = try self.parseIdentifierOrStringView();
            self.skipIgnored();
            if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
            self.advanceCursor(1);
            if (type_annot) |value| {
                type_annot = try self.pinView(value);
            }
        }

        self.skipIgnored();
        const token = try self.parseTokenRaw();

        self.skipIgnored();
        if (self.peek() == @as(?u8, '=')) {
            if (type_annot != null) return ParseError.InvalidSyntax;
            if (token.kind == .number or token.kind == .keyword) {
                return ParseError.InvalidSyntax;
            }
            var name = stringViewFromToken(token);
            name = try self.pinView(name);
            self.advanceCursor(1);
            self.skipIgnored();

            var val_type: ?stream_events.StringView = null;
            if (self.peek() == @as(?u8, '(')) {
                self.advanceCursor(1);
                self.skipIgnored();
                val_type = try self.parseIdentifierOrStringView();
                self.skipIgnored();
                if (self.peek() != @as(?u8, ')')) return ParseError.InvalidSyntax;
                self.advanceCursor(1);
                if (val_type) |value| {
                    val_type = try self.pinView(value);
                }
            }

            const value = try self.parseValueViewPinned();
            try sink.onEvent(.{
                .property = .{
                    .name = name,
                    .value = value,
                    .type_annotation = val_type,
                },
            });
        } else {
            const value = try self.parseValueViewFromTokenPinned(token);
            try sink.onEvent(.{
                .argument = .{
                    .value = value,
                    .type_annotation = type_annot,
                },
            });
        }
    }

    fn parseValue(self: *Self) ParseError!StreamValue {
        const token = try self.parseToken();
        return self.parseValueFromToken(token);
    }

    fn parseValueFromToken(self: *Self, token: TokenInfo) ParseError!StreamValue {
        switch (token.kind) {
            .identifier, .quoted_string, .raw_string, .multiline_string => {
                return StreamValue{ .string = token.str_ref.? };
            },
            .keyword => {
                if (std.mem.eql(u8, token.text, "#true")) return StreamValue{ .boolean = true };
                if (std.mem.eql(u8, token.text, "#false")) return StreamValue{ .boolean = false };
                if (std.mem.eql(u8, token.text, "#null")) return StreamValue{ .null_value = {} };
                if (std.mem.eql(u8, token.text, "#inf")) return StreamValue{ .positive_inf = {} };
                if (std.mem.eql(u8, token.text, "#-inf")) return StreamValue{ .negative_inf = {} };
                if (std.mem.eql(u8, token.text, "#nan")) return StreamValue{ .nan_value = {} };
                return ParseError.UnexpectedToken;
            },
            .number => return self.parseNumber(token.text),
        }
    }

    fn parseNumber(self: *Self, text: []const u8) ParseError!StreamValue {
        const doc = self.doc orelse unreachable;
        if (text.len == 0) return ParseError.InvalidNumber;

        var start: usize = 0;
        if (text[0] == '-' or text[0] == '+') start = 1;

        if (start + 1 < text.len and text[start] == '0') {
            const prefix = text[start + 1];
            if (prefix == 'x' or prefix == 'X') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 16) catch return ParseError.InvalidNumber;
                return StreamValue{ .integer = val };
            }
            if (prefix == 'o' or prefix == 'O') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 8) catch return ParseError.InvalidNumber;
                return StreamValue{ .integer = val };
            }
            if (prefix == 'b' or prefix == 'B') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 2) catch return ParseError.InvalidNumber;
                return StreamValue{ .integer = val };
            }
        }

        if (std.mem.indexOfAny(u8, text, ".eE") != null) {
            const result = numbers.parseFloat(self.allocator, text) catch return ParseError.InvalidNumber;
            defer if (result.original) |orig| self.allocator.free(orig);
            const orig_text = result.original orelse text;
            const ref = doc.strings.add(orig_text) catch return ParseError.OutOfMemory;
            return StreamValue{ .float = .{ .value = result.value, .original = ref } };
        }

        const val = numbers.parseDecimalInteger(self.allocator, text) catch return ParseError.InvalidNumber;
        return StreamValue{ .integer = val };
    }

    fn parseIdentifierOrString(self: *Self) ParseError!StringRef {
        const token = try self.parseToken();
        switch (token.kind) {
            .identifier, .quoted_string, .raw_string, .multiline_string => return token.str_ref.?,
            else => return ParseError.UnexpectedToken,
        }
    }

    fn parseIdentifierOrStringView(self: *Self) ParseError!stream_events.StringView {
        const token = try self.parseTokenRaw();
        switch (token.kind) {
            .identifier, .quoted_string, .raw_string, .multiline_string => {
                return stringViewFromToken(token);
            },
            else => return ParseError.UnexpectedToken,
        }
    }

    fn parseValueView(self: *Self) ParseError!stream_events.ValueView {
        const token = try self.parseTokenRaw();
        return self.parseValueViewFromToken(token);
    }

    fn parseValueViewFromToken(self: *Self, token: TokenInfo) ParseError!stream_events.ValueView {
        switch (token.kind) {
            .identifier, .quoted_string, .raw_string, .multiline_string => {
                return stream_events.ValueView{ .string = stringViewFromToken(token) };
            },
            .keyword => {
                if (std.mem.eql(u8, token.text, "#true")) return stream_events.ValueView{ .boolean = true };
                if (std.mem.eql(u8, token.text, "#false")) return stream_events.ValueView{ .boolean = false };
                if (std.mem.eql(u8, token.text, "#null")) return stream_events.ValueView{ .null_value = {} };
                if (std.mem.eql(u8, token.text, "#inf")) return stream_events.ValueView{ .positive_inf = {} };
                if (std.mem.eql(u8, token.text, "#-inf")) return stream_events.ValueView{ .negative_inf = {} };
                if (std.mem.eql(u8, token.text, "#nan")) return stream_events.ValueView{ .nan_value = {} };
                return ParseError.UnexpectedToken;
            },
            .number => return self.parseNumberView(token.text),
        }
    }

    fn parseValueViewPinned(self: *Self) ParseError!stream_events.ValueView {
        const token = try self.parseTokenRaw();
        return self.parseValueViewFromTokenPinned(token);
    }

    fn parseValueViewFromTokenPinned(self: *Self, token: TokenInfo) ParseError!stream_events.ValueView {
        if (token.kind == .identifier or
            token.kind == .quoted_string or
            token.kind == .raw_string or
            token.kind == .multiline_string)
        {
            const view = stringViewFromToken(token);
            const pinned = try self.pinView(view);
            return stream_events.ValueView{ .string = pinned };
        }
        return self.parseValueViewFromToken(token);
    }

    fn parseNumberView(self: *Self, text: []const u8) ParseError!stream_events.ValueView {
        if (text.len == 0) return ParseError.InvalidNumber;

        var start: usize = 0;
        if (text[0] == '-' or text[0] == '+') start = 1;

        if (start + 1 < text.len and text[start] == '0') {
            const prefix = text[start + 1];
            if (prefix == 'x' or prefix == 'X') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 16) catch return ParseError.InvalidNumber;
                return stream_events.ValueView{ .integer = val };
            }
            if (prefix == 'o' or prefix == 'O') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 8) catch return ParseError.InvalidNumber;
                return stream_events.ValueView{ .integer = val };
            }
            if (prefix == 'b' or prefix == 'B') {
                const val = numbers.parseRadixInteger(self.allocator, text, 2, 2) catch return ParseError.InvalidNumber;
                return stream_events.ValueView{ .integer = val };
            }
        }

        if (std.mem.indexOfAny(u8, text, ".eE") != null) {
            const result = numbers.parseFloat(self.allocator, text) catch return ParseError.InvalidNumber;
            defer if (result.original) |orig| self.allocator.free(orig);
            return stream_events.ValueView{ .float = .{ .value = result.value, .original = text } };
        }

        const val = numbers.parseDecimalInteger(self.allocator, text) catch return ParseError.InvalidNumber;
        return stream_events.ValueView{ .integer = val };
    }

    fn stringViewFromToken(token: TokenInfo) stream_events.StringView {
        return .{
            .text = token.text,
            .kind = stringKindFromToken(token.kind),
        };
    }

    fn stringKindFromToken(kind: TokenKind) stream_events.StringKind {
        return switch (kind) {
            .identifier => .identifier,
            .quoted_string => .quoted_string,
            .raw_string => .raw_string,
            .multiline_string => .multiline_string,
            else => unreachable,
        };
    }

    fn pinView(self: *Self, view: stream_events.StringView) ParseError!stream_events.StringView {
        if (!self.isScratchSlice(view.text)) return view;
        const start = self.event_scratch.items.len;
        try self.event_scratch.appendSlice(self.allocator, view.text);
        return .{
            .text = self.event_scratch.items[start .. start + view.text.len],
            .kind = view.kind,
        };
    }

    fn isScratchSlice(self: *Self, slice: []const u8) bool {
        const scratch = self.scratch.items;
        if (scratch.len == 0) return false;
        const base = @intFromPtr(scratch.ptr);
        const end = base + scratch.len;
        const ptr = @intFromPtr(slice.ptr);
        return ptr >= base and ptr < end;
    }

    fn parseToken(self: *Self) ParseError!TokenInfo {
        var token = try self.parseTokenRaw();
        switch (token.kind) {
            .identifier, .quoted_string, .raw_string, .multiline_string => {
                token.str_ref = try self.buildStringRef(token.kind, token.text);
            },
            else => {},
        }
        return token;
    }

    fn parseTokenRaw(self: *Self) ParseError!TokenInfo {
        if (self.cursor >= self.sourceLen()) return ParseError.UnexpectedEof;

        const start = self.cursor;
        const c = self.peek().?;

        if (c == '"') {
            return self.parseQuotedStringTokenRaw();
        }

        if (c == '#') {
            if (self.isRawStringStart()) {
                return self.parseRawStringTokenRaw();
            }
            const slice = try self.readHashToken();
            return TokenInfo{
                .kind = .keyword,
                .start = start,
                .end = self.cursor,
                .text = slice,
            };
        }

        if (c == '.') {
            if (self.peekAhead(1)) |next| {
                if (std.ascii.isDigit(next)) return ParseError.InvalidNumber;
            }
            return self.parseIdentifierTokenRaw();
        }

        if (c == '+' or c == '-') {
            if (self.peekAhead(1)) |next| {
                if (std.ascii.isDigit(next)) return self.parseNumberToken();
            }
            return self.parseIdentifierTokenRaw();
        }

        if (std.ascii.isDigit(c)) {
            return self.parseNumberToken();
        }

        return self.parseIdentifierTokenRaw();
    }

    fn parseIdentifierTokenRaw(self: *Self) ParseError!TokenInfo {
        const start = self.cursor;
        const slice = try self.readBareSlice();
        if (slice.len == 0) return ParseError.UnexpectedToken;
        if (grammar.isBareKeyword(slice)) return ParseError.InvalidSyntax;
        return TokenInfo{
            .kind = .identifier,
            .start = start,
            .end = self.cursor,
            .text = slice,
        };
    }

    fn parseNumberToken(self: *Self) ParseError!TokenInfo {
        const start = self.cursor;
        const slice = try self.readBareSlice();
        if (slice.len == 0) return ParseError.InvalidNumber;
        return TokenInfo{
            .kind = .number,
            .start = start,
            .end = self.cursor,
            .text = slice,
        };
    }

    fn buildStringRef(self: *Self, kind: TokenKind, text: []const u8) ParseError!StringRef {
        const doc = self.doc orelse unreachable;
        return switch (kind) {
            .identifier => value_builder.buildIdentifier(&doc.strings, text) catch return ParseError.OutOfMemory,
            .quoted_string => value_builder.buildQuotedString(&doc.strings, text) catch |err| return mapStringError(err),
            .raw_string => value_builder.buildRawString(&doc.strings, text) catch |err| return mapStringError(err),
            .multiline_string => value_builder.buildMultilineString(&doc.strings, text) catch |err| return mapStringError(err),
            else => return ParseError.UnexpectedToken,
        };
    }

    fn parseQuotedStringTokenRaw(self: *Self) ParseError!TokenInfo {
        const start = self.cursor;
        const len = self.sourceLen();
        const is_multiline = self.cursor + 2 < len and
            self.byteAt(self.cursor + 1).? == '"' and
            self.byteAt(self.cursor + 2).? == '"';

        if (is_multiline) {
            const close_pos = self.findNextQuotePos(self.cursor + 3) orelse return ParseError.UnexpectedEof;
            if (close_pos + 2 >= len or
                self.byteAt(close_pos + 1).? != '"' or
                self.byteAt(close_pos + 2).? != '"')
            {
                return ParseError.InvalidString;
            }
            const end_pos = close_pos + 2;
            const text = try self.sliceRange(start, end_pos + 1);
            self.advanceCursorTo(end_pos + 1);
            return TokenInfo{
                .kind = .multiline_string,
                .start = start,
                .end = self.cursor,
                .text = text,
            };
        }

        const close_pos = self.findNextQuotePos(self.cursor + 1) orelse return ParseError.UnexpectedEof;
        const text = try self.sliceRange(start, close_pos + 1);
        self.advanceCursorTo(close_pos + 1);
        return TokenInfo{
            .kind = .quoted_string,
            .start = start,
            .end = self.cursor,
            .text = text,
        };
    }

    fn parseRawStringTokenRaw(self: *Self) ParseError!TokenInfo {
        const start = self.cursor;
        const len = self.sourceLen();

        var hash_count: usize = 0;
        while (self.peekAhead(hash_count)) |ch| : (hash_count += 1) {
            if (ch != '#') break;
        }
        if (hash_count == 0) return ParseError.InvalidString;

        const quote_pos = start + hash_count;
        if (quote_pos >= len or self.byteAt(quote_pos).? != '"') {
            return ParseError.InvalidString;
        }

        const is_multiline = quote_pos + 2 < len and
            self.byteAt(quote_pos + 1).? == '"' and
            self.byteAt(quote_pos + 2).? == '"';

        const search_start: usize = quote_pos + (if (is_multiline) @as(usize, 3) else 1);
        const close_pos = self.findNextQuotePos(search_start) orelse return ParseError.UnexpectedEof;

        var end_pos: usize = 0;
        if (is_multiline) {
            if (close_pos + 2 >= len or
                self.byteAt(close_pos + 1).? != '"' or
                self.byteAt(close_pos + 2).? != '"')
            {
                return ParseError.InvalidString;
            }
            if (!self.matchesHashesAt(close_pos + 3, hash_count)) {
                return ParseError.InvalidString;
            }
            end_pos = close_pos + 2 + hash_count;
        } else {
            if (!self.matchesHashesAt(close_pos + 1, hash_count)) {
                return ParseError.InvalidString;
            }
            end_pos = close_pos + hash_count;
        }

        if (end_pos >= len) return ParseError.UnexpectedEof;
        const text = try self.sliceRange(start, end_pos + 1);
        self.advanceCursorTo(end_pos + 1);
        return TokenInfo{
            .kind = .raw_string,
            .start = start,
            .end = self.cursor,
            .text = text,
        };
    }

    fn findNextQuotePos(self: *Self, start_pos: usize) ?usize {
        var i = self.idx_pos;
        while (i < self.index.count and @as(usize, @intCast(self.index.indices[i])) < start_pos) {
            i += 1;
        }
        while (i < self.index.count) : (i += 1) {
            const pos = @as(usize, @intCast(self.index.indices[i]));
            if (pos < start_pos) continue;
            if (pos >= self.sourceLen()) break;
            if (self.byteAt(pos).? == '"') {
                self.idx_pos = i;
                return pos;
            }
        }
        return null;
    }

    fn readBareSlice(self: *Self) ParseError![]const u8 {
        const start = self.cursor;
        if (start >= self.sourceLen()) return "";
        const end = self.findTokenEnd(start);
        self.advanceCursorTo(end);
        return self.sliceRange(start, end);
    }

    fn readHashToken(self: *Self) ParseError![]const u8 {
        const start = self.cursor;
        if (start >= self.sourceLen()) return "";

        var pos = start + 1;
        while (pos < self.sourceLen()) : (pos += 1) {
            const c = self.byteAt(pos).?;
            if (c < 0x80 and grammar.isTokenTerminator(c)) break;
        }

        self.advanceCursorTo(pos);
        return self.sliceRange(start, pos);
    }

    fn findTokenEnd(self: *Self, start: usize) usize {
        var pos = start;
        const len = self.sourceLen();
        while (pos < len) : (pos += 1) {
            const c = self.byteAt(pos).?;
            if (c < 0x80 and grammar.isTokenTerminator(c)) break;
        }
        return pos;
    }

    fn nextStructuralPos(self: *Self) usize {
        self.syncIndex();
        if (self.idx_pos >= self.index.count) return self.sourceLen();
        return @intCast(self.index.indices[self.idx_pos]);
    }

    fn nextStructuralPosFrom(self: *Self, pos: usize) usize {
        var i = self.idx_pos;
        while (i < self.index.count and @as(usize, @intCast(self.index.indices[i])) < pos) {
            i += 1;
        }
        if (i >= self.index.count) {
            self.idx_pos = self.index.count;
            return self.sourceLen();
        }
        self.idx_pos = i;
        return @intCast(self.index.indices[i]);
    }

    fn syncIndex(self: *Self) void {
        while (self.idx_pos < self.index.count and @as(usize, @intCast(self.index.indices[self.idx_pos])) < self.cursor) {
            self.idx_pos += 1;
        }
    }

    fn advanceCursor(self: *Self, count: usize) void {
        if (count == 0) return;
        self.cursor += count;
        self.syncIndex();
    }

    fn advanceCursorTo(self: *Self, pos: usize) void {
        self.cursor = pos;
        self.syncIndex();
    }

    fn skipIgnored(self: *Self) void {
        while (self.cursor < self.sourceLen()) {
            const available = self.spanFrom(self.cursor);
            const ws_len = simd.findWhitespaceLength(available);
            if (ws_len > 0) {
                self.advanceCursor(ws_len);
                continue;
            }

            const c = self.peek().?;

            if (c == '\\' and self.trySkipLineContinuation()) {
                continue;
            }

            if (c == '/') {
                if (self.peekAhead(1)) |next| {
                    if (next == '/') {
                        self.cursor += 2;
                        while (self.cursor < self.sourceLen()) {
                            const nc = self.peek().?;
                            if (isNewline(nc)) break;
                            self.cursor += 1;
                        }
                        self.syncIndex();
                        continue;
                    }
                    if (next == '*') {
                        self.cursor += 2;
                        var depth: usize = 1;
                        while (self.cursor + 1 < self.sourceLen() and depth > 0) {
                            const a = self.byteAt(self.cursor).?;
                            const b = self.byteAt(self.cursor + 1).?;
                            if (a == '/' and b == '*') {
                                depth += 1;
                                self.cursor += 2;
                                continue;
                            }
                            if (a == '*' and b == '/') {
                                depth -= 1;
                                self.cursor += 2;
                                continue;
                            }
                            self.cursor += 1;
                        }
                        self.syncIndex();
                        continue;
                    }
                }
            }

            if (c >= 0x80) {
                if (self.decodeUtf8At()) |decoded| {
                    if (unicode.isWhitespace(decoded.codepoint)) {
                        self.advanceCursor(decoded.len);
                        continue;
                    }
                }
            }

            break;
        }
    }

    fn decodeUtf8At(self: *Self) DecodeUtf8Result {
        const span = self.spanFrom(self.cursor);
        if (span.len >= 4) {
            return unicode.decodeUtf8(span);
        }

        var buf: [4]u8 = undefined;
        var i: usize = 0;
        while (i < buf.len and self.cursor + i < self.sourceLen()) : (i += 1) {
            buf[i] = self.byteAt(self.cursor + i).?;
        }
        return unicode.decodeUtf8(buf[0..i]);
    }

    fn trySkipLineContinuation(self: *Self) bool {
        if (self.peek() != @as(?u8, '\\')) return false;

        var pos = self.cursor + 1;
        while (pos < self.sourceLen()) {
            const c = self.byteAt(pos).?;
            if (c == ' ' or c == '\t') {
                pos += 1;
                continue;
            }
            break;
        }

        if (pos < self.sourceLen() and isNewline(self.byteAt(pos).?)) {
            if (self.byteAt(pos).? == '\r' and pos + 1 < self.sourceLen() and self.byteAt(pos + 1).? == '\n') {
                pos += 2;
            } else {
                pos += 1;
            }
            self.advanceCursorTo(pos);
            return true;
        }

        return false;
    }

    fn consumeNewline(self: *Self) void {
        if (self.cursor >= self.sourceLen()) return;
        if (self.byteAt(self.cursor).? == '\r' and self.cursor + 1 < self.sourceLen() and self.byteAt(self.cursor + 1).? == '\n') {
            self.advanceCursor(2);
        } else {
            self.advanceCursor(1);
        }
    }

    fn peek(self: *Self) ?u8 {
        return self.byteAt(self.cursor);
    }

    fn peekAhead(self: *Self, offset: usize) ?u8 {
        const pos = self.cursor + offset;
        return self.byteAt(pos);
    }

    fn skipBOM(self: *Self) void {
        if (self.sourceLen() >= 3 and
            self.byteAt(0).? == 0xEF and
            self.byteAt(1).? == 0xBB and
            self.byteAt(2).? == 0xBF)
        {
            self.advanceCursorTo(3);
        }
    }

    fn isSlashdash(self: *Self) bool {
        return self.peek() == @as(?u8, '/') and self.peekAhead(1) == @as(?u8, '-');
    }

    fn isRawStringStart(self: *Self) bool {
        if (self.peek() != @as(?u8, '#')) return false;
        var pos = self.cursor;
        while (pos < self.sourceLen() and self.byteAt(pos).? == '#') {
            pos += 1;
        }
        return pos < self.sourceLen() and self.byteAt(pos).? == '"';
    }

    fn matchesHashesAt(self: *Self, start: usize, count: usize) bool {
        if (start + count > self.sourceLen()) return false;
        var i: usize = 0;
        while (i < count) : (i += 1) {
            if (self.byteAt(start + i).? != '#') return false;
        }
        return true;
    }
};

}

pub const IndexParser = IndexParserImpl([]const u8, ContiguousOps);
pub const ChunkedIndexParser = IndexParserImpl(ChunkedSourceCursor, ChunkedOps);

fn isNewline(c: u8) bool {
    return c == '\n' or c == '\r';
}

fn mapStringError(err: value_builder.Error) ParseError {
    return switch (err) {
        error.InvalidString => ParseError.InvalidString,
        error.InvalidEscape => ParseError.InvalidEscape,
        error.OutOfMemory => ParseError.OutOfMemory,
    };
}

pub fn initChunkedParser(
    allocator: std.mem.Allocator,
    source: structural.ChunkedSource,
    index: structural.StructuralIndex,
    doc: *StreamDocument,
    options: Options,
) ChunkedIndexParser {
    return ChunkedIndexParser.init(allocator, ChunkedSourceCursor.init(source), index, doc, options);
}

pub fn initChunkedKernelParser(
    allocator: std.mem.Allocator,
    source: structural.ChunkedSource,
    index: structural.StructuralIndex,
    options: Options,
) ChunkedIndexParser {
    return ChunkedIndexParser.initKernel(allocator, ChunkedSourceCursor.init(source), index, options);
}

pub fn parseWithOptions(allocator: std.mem.Allocator, source: []const u8, options: Options) ParseError!StreamDocument {
    const index = structural.scan(allocator, source, .{}) catch return ParseError.OutOfMemory;
    defer index.deinit(allocator);

    var doc = StreamDocument.init(allocator) catch return ParseError.OutOfMemory;
    errdefer doc.deinit();

    var parser = IndexParser.init(allocator, source, index, &doc, options);
    defer parser.deinit();
    try parser.parse();
    return doc;
}

pub fn parse(allocator: std.mem.Allocator, source: []const u8) ParseError!StreamDocument {
    return parseWithOptions(allocator, source, .{});
}

test "IndexParser basic" {
    const allocator = std.testing.allocator;
    const source = "node key=\"value\" { child 123; }";
    var doc = try parse(allocator, source);
    defer doc.deinit();

    try std.testing.expectEqual(@as(usize, 2), doc.nodes.count());
}
